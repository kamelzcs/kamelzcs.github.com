I"^<h4 id="lecture-contents">Lecture Contents</h4>

<p>The classification about <code class="highlighter-rouge">Levels of Abstraction</code> is really great.</p>

<blockquote>
  <p>With respect to Applicative and Monad in particular, there are just two levels to be concerned with. The first is the level of implementing various Applicative and Monad instances, i.e. the “raw Haskell” level.
Once we have an Applicative instance for a type like Parser, the point is that we get to “move up a layer” and program with Parsers using the Applicative interface, without thinking about the details of how Parser and its Applicative instance are actually implemented.</p>
</blockquote>

<p>The powerful <code class="highlighter-rouge">Type system</code> of <code class="highlighter-rouge">Haskell</code> makes it really suitable to create <code class="highlighter-rouge">Levels of Abstraction</code>,
which is usually very verbose or even impossible in other static typed programming languages.</p>

<h4 id="home-work">Home Work</h4>

<h5 id="exercise-1">Exercise 1</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">zeroOrMore</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">zeroOrMore</span> <span class="n">p</span> <span class="o">=</span> <span class="n">oneOrMore</span> <span class="n">p</span> <span class="o">&lt;|&gt;</span> <span class="n">pure</span> <span class="kt">[]</span>

<span class="n">oneOrMore</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">oneOrMore</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">p</span> <span class="o">&lt;*&gt;</span> <span class="n">zeroOrMore</span> <span class="n">p</span></code></pre></figure>

<h5 id="exercise-2">Exercise 2</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">spaces</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">spaces</span> <span class="o">=</span> <span class="n">zeroOrMore</span> <span class="o">$</span> <span class="n">satisfy</span> <span class="n">isSpace</span>

<span class="n">ident</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">ident</span> <span class="o">=</span> <span class="p">(</span><span class="o">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">isAlpha</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">zeroOrMore</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">isAlphaNum</span><span class="p">)</span></code></pre></figure>

<h5 id="exercise-3">Exercise 3</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="c1">-- An "identifier" is represented as just a String; however, only</span>
<span class="c1">-- those Strings consisting of a letter followed by any number of</span>
<span class="c1">-- letters and digits are valid identifiers.</span>
<span class="kr">type</span> <span class="kt">Ident</span> <span class="o">=</span> <span class="kt">String</span>

<span class="c1">-- An "atom" is either an integer value or an identifier.</span>
<span class="kr">data</span> <span class="kt">Atom</span> <span class="o">=</span> <span class="kt">N</span> <span class="kt">Integer</span> <span class="o">|</span> <span class="kt">I</span> <span class="kt">Ident</span>
  <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="c1">-- An S-expression is either an atom, or a list of S-expressions.</span>
<span class="kr">data</span> <span class="kt">SExpr</span> <span class="o">=</span> <span class="kt">A</span> <span class="kt">Atom</span>
           <span class="o">|</span> <span class="kt">Comb</span> <span class="p">[</span><span class="kt">SExpr</span><span class="p">]</span>
  <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="n">parseAtom</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Atom</span>
<span class="n">parseAtom</span> <span class="o">=</span> <span class="n">spaces</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="kt">N</span> <span class="o">&lt;$&gt;</span> <span class="n">posInt</span> <span class="o">&lt;|&gt;</span> <span class="kt">I</span> <span class="o">&lt;$&gt;</span> <span class="n">ident</span><span class="p">)</span> <span class="o">&lt;*</span> <span class="n">spaces</span>

<span class="n">parseComb</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">SExpr</span>
<span class="n">parseComb</span> <span class="o">=</span> <span class="n">spaces</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="kt">Comb</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'('</span> <span class="o">*&gt;</span> <span class="n">oneOrMore</span> <span class="n">parseSExpr</span> <span class="o">&lt;*</span> <span class="n">char</span> <span class="sc">')'</span><span class="p">))</span> <span class="o">&lt;*</span> <span class="n">spaces</span>

<span class="n">parseSExpr</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">SExpr</span>
<span class="n">parseSExpr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">A</span> <span class="o">&lt;$&gt;</span> <span class="n">parseAtom</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">parseComb</span></code></pre></figure>

<p>Test:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">*</span><span class="kt">SExpr</span><span class="o">&gt;</span> <span class="n">runParser</span> <span class="n">parseSExpr</span> <span class="s">"(   lots  of   (  spaces   in  )  this ( one ) )"</span>
<span class="kt">Just</span> <span class="p">(</span><span class="kt">Comb</span> <span class="p">[</span><span class="kt">A</span> <span class="p">(</span><span class="kt">I</span> <span class="s">"lots"</span><span class="p">),</span><span class="kt">A</span> <span class="p">(</span><span class="kt">I</span> <span class="s">"of"</span><span class="p">),</span><span class="kt">Comb</span> <span class="p">[</span><span class="kt">A</span> <span class="p">(</span><span class="kt">I</span> <span class="s">"spaces"</span><span class="p">),</span><span class="kt">A</span> <span class="p">(</span><span class="kt">I</span> <span class="s">"in"</span><span class="p">)],</span><span class="kt">A</span> <span class="p">(</span><span class="kt">I</span> <span class="s">"this"</span><span class="p">),</span><span class="kt">Comb</span> <span class="p">[</span><span class="kt">A</span> <span class="p">(</span><span class="kt">I</span> <span class="s">"one"</span><span class="p">)]],</span><span class="s">""</span><span class="p">)</span></code></pre></figure>

:ET