I"Å1<h4 id="lecture-contents">Lecture Contents</h4>

<p><code class="highlighter-rouge">Lazy evaluation</code> is beautiful because it makes infinite data structures possible.
But it makes reasoning about the programme harder, especially when mixed with <code class="highlighter-rouge">side effects</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Array</span>

<span class="n">knapsack01</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>   <span class="c1">-- values </span>
           <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>  <span class="c1">-- nonnegative weights</span>
           <span class="o">-&gt;</span> <span class="kt">Integer</span>    <span class="c1">-- knapsack size</span>
           <span class="o">-&gt;</span> <span class="kt">Double</span>     <span class="c1">-- max possible value</span>
<span class="n">knapsack01</span> <span class="n">vs</span> <span class="n">ws</span> <span class="n">maxW</span> <span class="o">=</span> <span class="n">m</span><span class="o">!</span><span class="p">(</span><span class="n">numItems</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxW</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">numItems</span> <span class="o">=</span> <span class="n">length</span> <span class="n">vs</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">array</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">numItems</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxW</span><span class="p">))</span> <span class="o">$</span>
              <span class="p">[((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">w</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">0</span> <span class="o">..</span> <span class="n">maxW</span><span class="p">]]</span> <span class="o">++</span>
              <span class="p">[((</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">0</span> <span class="o">..</span> <span class="n">numItems</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">++</span>
              <span class="p">[((</span><span class="n">i</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">best</span><span class="p">)</span> 
                  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">0</span> <span class="o">..</span> <span class="n">numItems</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                  <span class="p">,</span> <span class="n">w</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="n">maxW</span><span class="p">]</span>
                  <span class="p">,</span> <span class="kr">let</span> <span class="n">best</span>
                          <span class="o">|</span> <span class="n">ws</span><span class="o">!!</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">w</span>  <span class="o">=</span> <span class="n">m</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                          <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">max</span> <span class="p">(</span><span class="n">m</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span> 
                                            <span class="p">(</span><span class="n">m</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">-</span> <span class="n">ws</span><span class="o">!!</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">vs</span><span class="o">!!</span><span class="n">i</span><span class="p">)</span>
              <span class="p">]</span>

<span class="n">example</span> <span class="o">=</span> <span class="n">knapsack01</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="mi">20</span></code></pre></figure>

<p>The functional dynamic programming implementation is kind of tricky in my view.</p>

<p>Monolithic <a href="https://www.haskell.org/tutorial/arrays.html">Arrays</a> is used to memorized the overlapped subprobramme.</p>

<h4 id="home-work">Home Work</h4>

<h5 id="exercise-1">Exercise 1</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fib</span> <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">fib</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">fibs1</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
<span class="n">fibs1</span> <span class="o">=</span> <span class="n">map</span> <span class="n">fib</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span></code></pre></figure>

<h5 id="exercise-2">Exercise 2</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fibs2</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
<span class="n">fibs2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs2</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs2</span><span class="p">)</span></code></pre></figure>

<h5 id="exercise-3">Exercise 3</h5>

<p><code class="highlighter-rouge">cons</code> is mentioned in the lecture, but use record syntax makes it
much more cleaner.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Stream</span> <span class="p">{</span> <span class="n">streamToList</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="o">=</span>  <span class="n">show</span> <span class="o">.</span> <span class="n">take</span> <span class="mi">20</span> <span class="o">.</span> <span class="n">streamToList</span></code></pre></figure>

<h5 id="exercise-4">Exercise 4</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">streamRepeat</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span>
<span class="n">streamRepeat</span> <span class="o">=</span> <span class="kt">Stream</span> <span class="o">.</span> <span class="n">repeat</span>

<span class="n">streamMap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stream</span> <span class="n">b</span>
<span class="n">streamMap</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Stream</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">.</span> <span class="n">streamToList</span>

<span class="n">streamFromSeed</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span>
<span class="n">streamFromSeed</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Stream</span> <span class="o">.</span> <span class="n">iterate</span> <span class="n">f</span></code></pre></figure>

<h5 id="exercise-5">Exercise 5</h5>

<p><a href="http://codereview.stackexchange.com/questions/66700/implementing-function-that-maps-over-stream">Explanation</a></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">nats</span> <span class="o">::</span> <span class="kt">Stream</span> <span class="kt">Integer</span>
<span class="n">nats</span> <span class="o">=</span> <span class="kt">Stream</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span>

<span class="n">interleaveStreams</span> <span class="o">::</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span>
<span class="n">interleaveStreams</span> <span class="p">(</span><span class="kt">Stream</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">))</span> <span class="n">s</span> <span class="o">=</span>
  <span class="kt">Stream</span> <span class="o">$</span> <span class="n">x</span> <span class="o">:</span> <span class="n">streamToList</span> <span class="p">(</span><span class="n">interleaveStreams</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">xs</span><span class="p">))</span>


<span class="n">ruler</span> <span class="o">::</span> <span class="kt">Stream</span> <span class="kt">Integer</span>
<span class="n">ruler</span> <span class="o">=</span> <span class="n">foldr1</span> <span class="n">interleaveStreams</span> <span class="p">(</span><span class="n">map</span> <span class="n">streamRepeat</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">])</span></code></pre></figure>

:ET