I"l;<h4 id="lecture-contents">Lecture Contents</h4>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">f</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span></code></pre></figure>

<blockquote>
  <p>The reason this doesnâ€™t work is that the caller of a polymorphic function gets to choose the type. Here we, the implementors, have tried to choose a specific type</p>
</blockquote>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span></code></pre></figure>

<blockquote>
  <p>could be understood as a promise that a function with this type will work no matter what type the caller chooses</p>
</blockquote>

<h5 id="type-classes">Type classes</h5>
<blockquote>
  <p>Intuitively, type classes correspond to sets of types which have certain operations defined for them, and type class polymorphic functions work only for types which are instances of the type class(es) in question</p>
</blockquote>

<h4 id="home-work">Home Work</h4>

<h5 id="exercise-1">Exercise 1</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">eval</span> <span class="o">::</span> <span class="kt">ExprT</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>
<span class="n">eval</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">+</span> <span class="n">eval</span> <span class="n">e2</span>
<span class="n">eval</span> <span class="p">(</span><span class="kt">Mul</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">eval</span> <span class="n">e2</span></code></pre></figure>

<h5 id="exercise-2">Exercise 2</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">evalStr</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="n">evalStr</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">eval</span> <span class="o">.</span> <span class="n">parseExp</span> <span class="kt">Lit</span> <span class="kt">Add</span> <span class="kt">Mul</span></code></pre></figure>

<h5 id="exercise-3">Exercise 3</h5>

<p>Defination for <code class="highlighter-rouge">Expr</code></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">Expr</span> <span class="kr">where</span>

<span class="kr">class</span> <span class="kt">Expr</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">add</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">mul</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Expr</span> <span class="kt">ExprT</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="o">=</span> <span class="kt">Lit</span>
  <span class="n">add</span> <span class="o">=</span> <span class="kt">Add</span>
  <span class="n">mul</span> <span class="o">=</span> <span class="kt">Mul</span>

<span class="n">reify</span> <span class="o">::</span> <span class="kt">ExprT</span> <span class="o">-&gt;</span> <span class="kt">ExprT</span>
<span class="n">reify</span> <span class="o">=</span> <span class="n">id</span></code></pre></figure>

<h5 id="exercise-4">Exercise 4</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Expr</span> <span class="kt">Integer</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="o">=</span> <span class="n">id</span>
  <span class="n">add</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
  <span class="n">mul</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Expr</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="n">i</span>
    <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">False</span>
    <span class="o">|</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">=</span> <span class="kt">True</span>
  <span class="n">add</span> <span class="o">=</span> <span class="p">(</span><span class="o">||</span><span class="p">)</span>
  <span class="n">mul</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">MinMax</span> <span class="o">=</span> <span class="kt">MinMax</span> <span class="kt">Integer</span>
                 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Expr</span> <span class="kt">MinMax</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="o">=</span> <span class="kt">MinMax</span>
  <span class="n">add</span> <span class="p">(</span><span class="kt">MinMax</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">MinMax</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">MinMax</span> <span class="p">(</span><span class="n">max</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">mul</span> <span class="p">(</span><span class="kt">MinMax</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">MinMax</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">MinMax</span> <span class="p">(</span><span class="n">min</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Mod7</span> <span class="o">=</span> <span class="kt">Mod7</span> <span class="kt">Integer</span>
                 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Expr</span> <span class="kt">Mod7</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Mod7</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span><span class="p">)</span>
  <span class="n">add</span> <span class="p">(</span><span class="kt">Mod7</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">Mod7</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Mod7</span> <span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span><span class="p">)</span>
  <span class="n">mul</span> <span class="p">(</span><span class="kt">Mod7</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">Mod7</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Mod7</span> <span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span><span class="p">)</span></code></pre></figure>

<h5 id="exercise-5">Exercise 5</h5>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Expr</span> <span class="kt">Program</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="kt">PushI</span> <span class="n">x</span><span class="p">]</span>
  <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span> <span class="o">++</span> <span class="p">[</span><span class="kt">Add</span><span class="p">]</span>
  <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span> <span class="o">++</span> <span class="p">[</span><span class="kt">Mul</span><span class="p">]</span></code></pre></figure>

<h5 id="exercise-6">Exercise 6</h5>

<p>There are two tricky parts from my view:</p>

<ol>
  <li>
    <p>Same expression can belong to multiple types,
both <code class="highlighter-rouge">add (lit 3) (var "x") :: (M.Map String Integer -&gt; Maybe Integer)</code> and <code class="highlighter-rouge">add (lit 3) (var "x") :: VarExprT</code> are valid</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">add e1 e2 m</code> has the type of <code class="highlighter-rouge">(M.Map String Integer -&gt; Maybe Integer) -&gt; (M.Map String Integer -&gt; Maybe Integer) -&gt; (M.Map String Integer -&gt; Maybe Integer)</code></p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">VarExprT</span> <span class="o">=</span> <span class="kt">Lit</span> <span class="kt">Integer</span>
              <span class="o">|</span> <span class="kt">Add</span> <span class="kt">VarExprT</span> <span class="kt">VarExprT</span>
              <span class="o">|</span> <span class="kt">Mul</span> <span class="kt">VarExprT</span> <span class="kt">VarExprT</span>
              <span class="o">|</span> <span class="kt">Var</span> <span class="kt">String</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Expr</span> <span class="kt">VarExprT</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="o">=</span> <span class="kt">Lit</span>
  <span class="n">add</span> <span class="o">=</span> <span class="kt">Add</span>
  <span class="n">mul</span> <span class="o">=</span> <span class="kt">Mul</span>

<span class="kr">class</span> <span class="kt">HasVars</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">var</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">HasVars</span> <span class="kt">VarExprT</span> <span class="kr">where</span>
  <span class="n">var</span> <span class="o">=</span> <span class="kt">Var</span>

<span class="kr">instance</span> <span class="kt">HasVars</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">var</span> <span class="o">=</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span>

<span class="kr">instance</span> <span class="kt">Expr</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">lit</span> <span class="o">=</span>  <span class="n">const</span> <span class="o">.</span> <span class="kt">Just</span>
    <span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">e1</span> <span class="n">m</span> <span class="o">&lt;*&gt;</span> <span class="n">e2</span> <span class="n">m</span>
    <span class="n">mul</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">e1</span> <span class="n">m</span> <span class="o">&lt;*&gt;</span> <span class="n">e2</span> <span class="n">m</span>

<span class="n">withVars</span> <span class="o">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span>
         <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span><span class="p">)</span>
         <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="n">withVars</span> <span class="n">vs</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span> <span class="o">$</span> <span class="kt">M</span><span class="o">.</span><span class="n">fromList</span> <span class="n">vs</span></code></pre></figure>

:ET