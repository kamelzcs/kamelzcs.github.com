I"‹<h2 id="command-line-processing">Command Line Processing</h2>

<p>Each line the shell get is called a <em>pipeline</em>, it contains commands which are seperated by the pipe character(|).
For each pipeline it gets, the shell will breaks it into commands, set up the I/O for the pipeline and follows the
following figure to excecute the commands.</p>

<p><img src="/images/posts/bash-commandline/bash.jpg" alt="alt text" /></p>

<ol>
  <li>
    <p>Split the command into tokens by the metacharacters set: <code class="highlighter-rouge">SPACE, TAB, NEWLINE, ;, (, ), &lt;, &gt;, |, and &amp;.</code>
Types of tokens include: <code class="highlighter-rouge">words, keywords, I/O redirectors, and semicolons.</code></p>
  </li>
  <li>
    <p>Checks the first token of each command to see if it is a keyword with no quotes or backslashes. If it is an opening keyword, 
such as <code class="highlighter-rouge">if</code> or orther control-structure openers, then the shell sets things up internally for compound commands, reads the next command,
and start process again.</p>
  </li>
  <li>
    <p>Checks the first word of each command against the list of aliases. If a match is found, it substitudes and go back to Step 1.
This scheme allows recursive aliases.</p>
  </li>
  <li>
    <p>Performs brace expansion. For example, <code class="highlighter-rouge">a{b,c}</code> becomes <code class="highlighter-rouge">ab</code> <code class="highlighter-rouge">ac</code>.</p>
  </li>
  <li>
    <p>Substitudes the userâ€™s home directory(<code class="highlighter-rouge">$HOME</code>) for tilde if it is at the beginning of a word.</p>
  </li>
  <li>
    <p>Performs parameter(variable) substitution for any expression that starts with a dollar sign(<code class="highlighter-rouge">$</code>).</p>
  </li>
  <li>
    <p>Does command substitution for any expression of the form $(string).</p>
  </li>
  <li>
    <p>Evaluates arithmetic expressions of the form $((string)).</p>
  </li>
  <li>
    <p>Takes the parts of the line that resulted from parameter, command, and arithmetic substitution and splits them into words again.
This time it uses the characters in <code class="highlighter-rouge">$IFS</code> which usually is whitespace (space, tab, and newline).</p>
  </li>
  <li>
    <p>Performs pathname expansion, a.k.a. wildcard expansion, for any occurrences of <code class="highlighter-rouge">*</code> <code class="highlighter-rouge">?</code> and <code class="highlighter-rouge">[/]</code> pairs.</p>
  </li>
  <li>
    <p>Uses the first word as a command by looking up its source as a function command, then as a built-in, then as a file in any of the directories
in <code class="highlighter-rouge">$PATH</code></p>
  </li>
  <li>
    <p>Runs the command after setting up I/O redirection and other such things.</p>
  </li>
</ol>

<h3 id="reference">Reference</h3>
<p>[1] <a href="http://shop.oreilly.com/product/9780596009656.do">Learning the bash shell</a></p>

:ET