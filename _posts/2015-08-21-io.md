---
layout: post
title: IO
date: 2015-08-21 21:08:38
isOriginal: true
category: Functional Programming
tags:
 - Haskell
 - CIS194
keywords: 
description: IO
---

#### Lecture Contents

>There is no String “inside” an `IO String`, `IO String` is a promise, to produce a String requires actually executing the computation. And the only way to do that is to give it (perhaps as part of some larger IO value) to the Haskell runtime system, via main.

#### Home Work

##### Exercise 1

{%highlight haskell%}
-- 1. define glCons, which adds an Employee to GuestList

glCons :: Employee -> GuestList -> GuestList
glCons e (GL es fun) = GL (e:es) (fun + empFun e)


-- 2. define a Monoid instance for GuestList

instance Monoid GuestList where
  mempty  = GL [] 0
  mappend (GL es1 f1) (GL es2 f2) = GL (es1 ++ es2) $ f1 + f2

-- 3. define moreFun, which takes two GuestLists and returns the one
-- which has more fun

moreFun :: GuestList -> GuestList -> GuestList
moreFun = max
{%endhighlight%}

##### Exercise 2

{%highlight haskell%}
treeFold :: (a -> [b] -> b) -> Tree a -> b
treeFold f (Node a []) = f a []
treeFold f (Node a forest) = f a (map (treeFold f) forest)
{%endhighlight%}

##### Exercise 3

{%highlight haskell%}
nextLevel :: Employee -> [(GuestList, GuestList)] -> (GuestList, GuestList)
nextLevel b gls = (withBoss, withoutBoss)
  where
    withoutBoss = mconcat $ map (uncurry moreFun) gls
    withBoss = glCons b $ mconcat $ map snd gls
{%endhighlight%}


##### Exercise 4

{%highlight haskell%}
maxFun :: Tree Employee -> GuestList
maxFun = uncurry moreFun . treeFold nextLevel
{%endhighlight%}

##### Exercise 5

{%highlight haskell%}
formatGLS :: GuestList -> String
formatGLS (GL es fun) =
  totalStr ++ "\n" ++ nameStr
  where
    totalStr = "Total fun: " ++ show fun
    nameStr = unlines $ sort $ map empName es

main :: IO ()
main = readFile "company.txt" >>= putStrLn . formatGLS . maxFun . read
{%endhighlight%}
