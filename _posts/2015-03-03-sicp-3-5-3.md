---
layout: post
title: sicp-3-5-3
date: 2015-03-03 13:24:29
isOriginal: true
category: SICP
tags:
 - Lisp
keywords: 
description: 
---

#### 3.63

`guess` is used to share the computation result between the succssive calling.
Otherwise each call to `sqrt-stream x` would require recursively calling.

If `memo-proc` is not used, these two versions would be the same efficiency.

#### 3.64

{%highlight scheme%}
(define (stream-limit s tolerance)
  (let ((s2 (stream-cdr s)))
    (if (< (abs
             (-
               (stream-car s)
               (stream-car s2)))
           tolerance)
      (stream-car s2)
      (stream-limit s2 tolerance))))
{%endhighlight%}

#### 3.65

{%highlight scheme%}
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))           ; Sn-1
        (s1 (stream-ref s 1))           ; Sn
        (s2 (stream-ref s 2)))          ; Sn+1
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))

(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform
                             (transform s))))
(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))
(define (log2-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (log2-summands (+ n 1)))))
(define log2-stream
  (partial-sums (log2-summands 1)))

(stream-limit
  (accelerated-sequence euler-transform log2-stream) 0.0001)
{%endhighlight%}

#### 3.66

| 1 | 2 | 4 | 6  | 8  |
|---|---|---|----|----|
|   | 3 | 5 | 9  | 13 |
|   |   | 7 | 11 | 19 |
|   |   |   | 15 | 23 |

The order to traverse the pair is listed as above.
Some observations:

$(i,i)=2^i-1$

$(i, i + 1) = 3*2^{i-1}-1$

$(i, k) = 3*2^{i-1}-1 + (k- i - 1) * 2^i$

#### 3.67

{%highlight scheme%}
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
     (interleave
       (stream-map (lambda (x) (list (stream-car s) x))
                   (stream-cdr t))
       (stream-map (lambda (x) (list x (stream-car t)))
                   (stream-cdr s)))
     (pairs (stream-cdr s) (stream-cdr t)))))
{%endhighlight%}

#### 3.68

Only the `cons-stream` is a normal-order function, while `interleave` is not.
When `interleave` evaluate its two parameters, which includes `pair`, would lead to
infinite loop.

#### 3.69

{%highlight scheme%}
(define (triples s1 s2 s3)
  (cons-stream
    (list (stream-car s1)
          (stream-car s2)
          (stream-car s3))
    (interleave
      (stream-map
        (lambda (x) (append (list (stream-car s1))
                            x))
        (stream-cdr
          (pair s2 s3)))
      (triples (stream-cdr s1)
               (stream-cdr s2)
               (stream-cdr s3)))))
{%endhighlight%}

