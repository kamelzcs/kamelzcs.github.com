---
layout: post
title: sicp-2.3.3
date: 2015-02-22 14:54:30
isOriginal: true
category: SICP
tags:
 - Lisp
keywords: 
description: 
---

#### 2.59

{%highlight scheme%}
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1) set2))
        (else
          (cons (car set1)
                (union-set (cdr set1)
                           set2)))))
{%endhighlight%}

#### 2.60

{%highlight scheme%}
(define (adjoin-set x set)
   (cons x set))

(define (union-set set1 set2)
  (append set1 set2))
{%endhighlight%}

`adjoin-set` goes from $O(n)$ to $O(1)$

`union-set` goes from $O(n^2)$ to $O(n)$

#### 2.61

{%highlight scheme%}
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< x (car set)) (cons x set))
        ((= x (car set)) set)
        ((> x (car set)) (cons (car set)
                               (adjoin-set x (cdr set))))))
{%endhighlight%}

#### 2.62

{%highlight scheme%}
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else
          (let* ([x1 (car set1)] [x2 (car set2)])
            (cond ((< x1 x2)
                   (cons x1
                         (union-set (cdr set1) set2)))
                  ((= x1 x2)
                   (cons x1
                         (union-set (cdr set1) (cdr set2))))
                  (else
                    (cons x2
                          (union-set set1 (cdr set2)))))))))
{%endhighlight%}

#### 2.63
It would make no difference on the final result, both of them are in order traverse.
But there is something tricky on the time complexity[1].

`append` is much more expensive than `cons`.

Let $T(n)$ be the time complexity for a balanced tree of $n$ nodes.

For tree->list-1:

$$
T(n) = 2 * T(n/2) + O(n) = O(nlog n)
$$

For tree->list-2:

$$
T(n) = 2 * T(n/2) + O(1) = O(n)
$$

#### 2.64
The analysis of time complexity is similar to the `2.63`, which is $O(nlog n)$.

#### 2.65
Use `tree-list` from `2.63` and `list-tree` to convert bidirectional.

{%highlight scheme%}
 (define (union-set tree1 tree2)
   (list->tree (union-set-list (tree->list tree1)
                               (tree->list tree2))))

 (define (intersection-set tree1 tree2)
   (list->tree (intersection-set-list (tree->list tree1)
                                      (tree->list tree2))))
{%endhighlight%}

#### 2.66

{%highlight scheme%}
(define (lookup given-key set-of-records)
  (if (null? set-of-records)
    #f
    (let ([record (entry set-of-records)])
      (cond ((= given-key (key record)) record)
            ((< given-key (key record))
             (lookup given-key
                     (left-branch set-of-records)))
            ((> given-key (key record))
             (lookup given-key 
                     (right-branch set-of-records)))))))
{%endhighlight%}


[1]: http://community.schemewiki.org/?sicp-ex-2.63
