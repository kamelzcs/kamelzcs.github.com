---
layout: post
title: sicp-2-2-2
date: 2015-02-17 11:56:36
isOriginal: true
category: SICP
tags:
 - Lisp
keywords: 
description: 
---

#### 2.24

The interpreter would show `(1 (2 (3 4)))`.

#### 2.25

{%highlight scheme%}
(cadr (caddr '(1 3 (5 7) 9)))
(caar '((7)))
(cadr (cadr (cadr (cadr (cadr (cadr '(1 (2 (3 (4 (5 (6 7))))))))))))
{%endhighlight%}

#### 2.26

{%highlight scheme%}

(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y)
->
(1 2 3 4 5 6)

(cons x y)
->
((1 2 3) 4 5 6)

(list x y)
->
((1 2 3) (4 5 6))
{%endhighlight%}

#### 2.27

{%highlight scheme%}
(define (deep-reverse items)
  (cond ((pair? items)
         (if (pair? (car items))
           (append
             (deep-reverse (cdr items))
             (list (deep-reverse (car items))))
           (append (deep-reverse (cdr items))
                   (deep-reverse (car items)))))
        (else
          (if (null? items)
            null
            (list items)))))
{%endhighlight%}

#### 2.28

{%highlight scheme%}
(define (deep-reverse items)
  (cond ((pair? items)
         (if (pair? (car items))
           (append
             (deep-reverse (cdr items))
             (list (deep-reverse (car items))))
           (append (deep-reverse (cdr items))
                   (deep-reverse (car items)))))
        (else
          (if (null? items)
            null
            (list items)))))
(define (fringe tree)
  (cond ((pair? tree)
         (append (fringe (car tree))
                 (fringe (cdr tree))))
        (else
          (if (null? tree)
            null
            (list tree)))))
{%endhighlight%}

#### 2.29

{%highlight scheme%}
(define (make-mobile left right)
   (list left right))

(define (make-branch length structure)
   (list length structure))

(define (left-branch mobile)
   (car mobile))

(define (right-branch mobile)
   (cadr mobile))

(define (branch-length branch)
   (car branch))

(define (branch-structure branch)
   (cadr branch))

(define (total-weight mobile)
   (+ (branch-weight (left-branch mobile))
      (branch-weight (right-branch mobile))))

(define (branch-weight branch)
  (let ([structure (branch-structure branch)])
    (if (pair? structure)
      (total-weight structure)
      structure)))

(define (balanced? mobile)
  (if (pair? mobile)
    (let* ([left (left-branch mobile)]
          [right (right-branch mobile)]
          [left-mobile (branch-structure left)]
          [right-mobile (branch-structure right)])
      (and
        (= (*
             (branch-length left)
             (if (pair? left-mobile)
               (total-weight left-mobile)
               left-mobile))
           (*
             (branch-length right)
             (if (pair? right-mobile)
              (total-weight right-mobile)
              right-mobile)))
        (balanced? left-mobile)
        (balanced? right-mobile)))
    #t))
{%endhighlight%}

#### 2.30

{%highlight scheme%}
(define (scale-tree tree factor)
   (cond ((null? tree) null)
         ((not (pair? tree)) (* tree factor))
         (else (cons (scale-tree (car tree) factor)
                     (scale-tree (cdr tree) factor)))))

(define (scale-tree tree factor)
   (map (lambda (sub-tree)
          (if (pair? sub-tree)
              (scale-tree sub-tree factor)
              (* sub-tree factor)))
        tree))

(define (square-tree tree)
   (cond ((null? tree) null)
         ((not (pair? tree)) (* tree tree))
         (else (cons (square-tree (car tree))
                     (square-tree (cdr tree))))))

(define (square-tree tree)
   (map (lambda (sub-tree)
          (if (pair? sub-tree)
              (square-tree sub-tree)
              (* sub-tree sub-tree)))
        tree))
{%endhighlight%}

#### 2.31

{%highlight scheme%}
(define (tree-map f tree)
  (cond ((null? tree) null)
        ((not (pair? tree)) (f tree))
        (else (cons (tree-map f (car tree))
                    (tree-map f (cdr tree))))))

(define (tree-map f tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree) (tree-map f sub-tree) (f sub-tree)))
       tree))
{%endhighlight%}

#### 2.32

{%highlight scheme%}
(define (subsets s)
  (if (null? s)
      (list null)
      (let ([rest (subsets (cdr s))])
        (append rest
                (map
                  (lambda (x)
                    (append (list (car s)) x))
                  rest)))))
{%endhighlight%}
