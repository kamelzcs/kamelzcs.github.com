---
layout: post
title: sicp-2.2.3
date: 2015-02-18 10:31:27
isOriginal: true
category: SICP
tags:
 - Lisp
keywords: 
description: 
---

#### 2.33

{%highlight scheme%}

(define (accumulate op initial sequence)
   (if (null? sequence)
       initial
       (op (car sequence)
           (accumulate op initial (cdr sequence)))))

(accumulate + 0 (list 1 2 3 4 5))

(define (map p sequence)
   (accumulate (lambda (x y) (cons (p x) y)) null sequence))

(define (square x) (* x x))

(map square '(1 2 3))

(define (append seq1 seq2)
   (accumulate cons seq2 seq1))

(append (list 1 2 3) (list 4 5 6))

(define (length sequence)
   (accumulate (lambda (x y) (+ 1 y)) 0 sequence))

(length '(1 2 3))
{%endhighlight%}

The `append` is kind of tricky to me at first glance.
Just remaind me this equition: `cons 1 (list 2 3) = (list 1 2 3)`

#### 2.34
{%highlight scheme%}

(define (horner-eval x coefficient-sequence)
   (accumulate (lambda (this-coeff higher-terms)
                 (+ this-coeff
                    (* x higher-terms)))
               0
               coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
{%endhighlight%}

#### 2.35
{%highlight scheme%}

(define (count-leaves t)
   (accumulate + 0 (map
                     (lambda (x)
                       (if (not (pair? x))
                         1
                         (count-leaves x)))
                     t)))

{%endhighlight%}

This is the most elegant way, which flats the tree structure recursively.

#### 2.36
{%highlight scheme%}

(define (accumulate-n op init seqs)
   (if (null? (car seqs))
       null
       (cons (accumulate op init
                         (map (lambda (x)
                                (car x))
                              seqs))
             (accumulate-n op init
                           (map (lambda (x)
                                  (cdr x))
                                seqs)))))

(accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))

{%endhighlight%}

#### 2.37
{%highlight scheme%}

(define (dot-product v w)
   (accumulate + 0 (map * v w)))

(define (matrix-*-vector m v)
   (map (lambda (row)
          (dot-product v row)) m))

(define m0 '((1 2 3 4) (4 5 6 6) (6 7 8 9)))
(matrix-*-vector m0 '( 2 1 4 5))

(define (transpose mat)
   (accumulate-n cons null  mat))

(transpose m0)

(define (matrix-*-matrix m n)
   (let ([cols (transpose n)])
      (map (lambda(v) (matrix-*-vector cols v)) m)))

(matrix-*-matrix m0 (transpose m0))
{%endhighlight%}

The key idea to understand `map` is relate it with [Category Theory][1]

[1]: http://en.wikibooks.org/wiki/Haskell/Category_theory
