---
layout: post
title: Monads
date: 2015-08-24 10:16:47
isOriginal: true
category: Functional Programming
tags:
 - Haskell
 - CIS194
keywords: 
description: Monads
---

#### Lecture Contents

[Type class][1] really gives one good intuition about `Monad`.

>Intuitively, it is this ability to use the output from previous computations to decide what computations to run next that makes Monad more powerful than Applicative. The structure of an Applicative computation is fixed, whereas the structure of a Monad computation can change based on intermediate results. This also means that parsers built using an Applicative interface can only parse context-free languages; in order to parse context-sensitive languages a Monad interface is needed

[Category theory][2] gives some theorems behind `Monad`.

>All told, a monad in X is just a monoid in the category of endofunctors of X, with product Ã— replaced by composition of endofunctors and unit set by the identity endofunctor.

#### Home Work

##### Exercise 2
{%highlight haskell%}
battle :: Battlefield -> Rand StdGen Battlefield
battle b = do
    (aStream :: [DieValue]) <- getRandoms
    (bStream :: [DieValue]) <- getRandoms
    let rollPairs = zip (sort . take numAttackRolls   $ aStream)
                        (sort . take numDefenderRolls $ bStream)
    return $ foldl' (\newB (attackRoll, defendRoll) ->
                        if attackRoll > defendRoll
                        then newB { defenders = defenders newB - 1}
                        else newB { attackers = attackers newB - 1})
                    b
                    rollPairs
  where
    numAttackRolls   = min 3 (attackers b - 1)
    numDefenderRolls = min 2 (defenders b)
{%endhighlight%}

##### Exercise 3

{%highlight haskell%}
invade :: Battlefield -> Rand StdGen Battlefield
invade bf@(Battlefield a b)
  | a == 1 || b == 0 = return bf
  | otherwise = battle bf >>= invade
{%endhighlight%}

##### Exercise 4

{%highlight haskell%}
successProb :: Battlefield -> Rand StdGen Double
successProb bf = do
  let num = 10000
  results <- replicateM num (invade bf)
  return $ fromIntegral (wins results) / fromIntegral num
  where wins = length . filter ((==0) . defenders)
{%endhighlight%}

Test code:

{%highlight haskell%}
*Risk> evalRandIO  $ successProb $ Battlefield 2 3
0.1338
{%endhighlight%}


[1]:https://wiki.haskell.org/Typeclassopedia
[2]:http://yogsototh.github.io/Category-Theory-Presentation/categories.html#slide-71

